//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//      File: inc_rw.bt
//   Authors: Laurynas Zubavičius (Sparagas)
//   Purpose: RenderWare Binary Stream
//  Category: Include file
//------------------------------------------------

#include "vector.bt"
#include "color.bt"


string IDUnpackVersion(uint32 libid) {
    int ver;
    if (libid & 0xFFFF0000)
        ver = (libid >> 14 & 0x3FF00) + 0x30000 |
              (libid >> 16 & 0x3F);
    else
        ver = libid << 8;
    string s;   
    SPrintf(s, "0x%x", ver);
    return s;
    }

enum <uint32> GeometryAttributes {
    none                   = 0x0,
    Triangle               = 0x1,
    VertexPositions        = 0x2,
    TextCoords             = 0x4,
    VertexColors           = 0x8,
    Normals                = 0x10,
    Lights                 = 0x20,
    ModulateMaterialColors = 0x40,
    MultipleTextCoords     = 0x80,

    NativeGeometry = 0x1000000,
    NativeInstance = 0x2000000,
    SectorsOverlap = 0x40000000
};

enum <uint32> RwId {
    // Core
    STRUCT          = 0x1,
    STRING          = 0x2,
    EXTENSION       = 0x3,
    TEXTURE         = 0x6,
    MATERIAL        = 0x7,
    MATERIAL_LIST   = 0x8,
    ATOMIC_SECTION  = 0x9,
    PLANE_SECTION   = 0xA,
    WORLD           = 0xB,
    RIGHT_TO_RENDER = 0x1F,
    // Toolkit
    PVS_PLG           = 0x106,
    PS2_MIPMAP_VAL    = 0x110,
    COLLISION_PLG     = 0x11D,
    USER_DATA_PLG     = 0x11F,
    GEOMETRIC_PVS_PLG = 0x12A,
    // World
    BIN_MESH_PLG    = 0x50E,
    NATIVE_DATA_PLG = 0x510,
    UNK_WORLD_PLG   = 0x511
};

typedef struct {
    RwId   id;
    uint32 len;
    uint32 ver <read=IDUnpackVersion>;
} RWHead <read=EnumToString(id)>;

// generic and should be replaced
struct RWStruct {
    RWHead head;
    ubyte  data[head.len];
};

struct RWString {
    RWHead head;
    char   str[head.len];
};

struct RWStructExtension {
    RWHead head;
    switch (head.id) {
        case 0x1F  : RightToRender(); break;
        case 0x106 : PVSPLG(); break;
        case 0x110 : PS2MipmapVal(); break;
        case 0x11D : CollisionPLG(); break;
        case 0x11F : UserDataPLG(); break;
        case 0x12A : GeometricPVSPLG(); break;
        case 0x50E : BinMeshPLG(); break;
        case 0x510 : NativeDataPLG(); break;
        case 0x511 : UnkWorldPLG(); break;
        default    : ubyte  unk[head.len];
    }
};

struct RWExtension {
    RWHead head;

    local int len = head.len;
    while (len) {
        RWStructExtension rw_struct;
        len = len - sizeof(rw_struct);
    }
};

struct RWStructTexture {
    RWHead head;
    uint32 filtering : 8;
    uint32 u         : 4;
    uint32 v         : 4;
    uint32 mipmap    : 1;
};

struct RWTexture {
    RWHead          head;
    RWStructTexture rw_struct;
    RWString        rw_tex_name;
    RWString        rw_tex_alpha_name;
    RWExtension     rw_extension;
};

struct RWStructMaterial {
    RWHead head;
    int32  flags; // unused
    RGBA   color;
    int32  unk; // marked as unused, but it is used
    int32  isTextured;
    // if version > 0x30400 // but I have 0x30400 and it is still present
        float  ambient;
        float  specular;
        float  diffuse;
};

struct RWMaterial {
    RWHead           head;
    RWStructMaterial rw_struct;

    if (rw_struct.isTextured)
        RWTexture    rw_texture;

    RWExtension      rw_extension;
};

struct RWStructMaterialList {
    RWHead head;
    uint32 num_material;
     int32 material_idx[num_material];
};

struct RWMaterialList {
    RWHead               head;
    RWStructMaterialList rw_struct;
    
    local int i, num_unique_material = 0;
    for (i = 0; i < rw_struct.num_material; i++)
        if (rw_struct.material_idx[i] == -1)
            num_unique_material++;
    
    RWMaterial rw_material[num_unique_material] <optimize=false>;
};

struct RWStructAtomicSection {
    RWHead head;
    uint32 mat_list_window_base;
    uint32 num_triangles; // need to test if it is realy triangles
    uint32 num_vertices;
    f32x3_geo bbox_min;
    f32x3_geo bbox_max;
    uint32 unk_coll_sector_present; // sometimes it looks like float
    uint32 unused;
    if (head.len > 11*4) ubyte data[head.len - 11*4]; // debug - some times there are buffers inside
};

struct RWAtomicSection {
    RWHead                head;
    RWStructAtomicSection rw_struct;
    RWExtension           rw_extension;
};

struct RWStructPlaneSection {
    RWHead head;
    uint32 unk_type;
    float  unk_value;
    int32  is_left_atomic;
    int32  is_right_atomic;
    float  unk_left_value;
    float  unk_right_value;
};

struct RWPlaneSection; // forward declaration for recursive structure
struct RWPlaneSection {
    RWHead head;
    RWStructPlaneSection rw_struct;
    
    if (rw_struct.is_left_atomic)
        RWAtomicSection left_atomic_section;
    else
        RWPlaneSection  left_plane_section;

    if (rw_struct.is_right_atomic)
        RWAtomicSection right_atomic_section;
    else
        RWPlaneSection  right_plane_section;  
};

struct RWStructWorld {
    RWHead head;
    uint32 is_world_root;
    f32x3_geo  inverse_origin;

    if (head.len == 52)
        f32x3_geo bbox_max_center; // need example to test it

    uint32 num_triangles; // need to test if realy triangles
    uint32 num_vertices;
    uint32 num_plane_sectors;
    uint32 num_atomic_sectors;
    uint32 unk_col_sector_size;
    uint32 geometry_attributes; // TODO

    if (head.len == 64) {
        f32x3_geo bbox_max;
        f32x3_geo bbox_min;
    }
};

struct RWWorld {
    RWHead         head;
    RWStructWorld  rw_struct;
    RWMaterialList rw_material_list;
    
    if (rw_struct.is_world_root)
        RWAtomicSection rw_atomic_section;
    else
        RWPlaneSection  rw_plane_section;

    RWExtension         rw_extension;
};

void RightToRender() {
    uint32 rw_plugin_id;  // maybe RWId?
    uint32 extra_data;
}

void PVSPLG() {
    ubyte unk_pvs_data[head.len];
}

void PS2MipmapVal() {
    uint32 k_l_value; // TODO
}

void CollisionPLG() {
    ubyte unk_collission_data[head.len];
}

enum <uint32> DataType {
    integer_32 = 1,
    float_32   = 2,
    str_ascii  = 3
};

struct EntryUserDataPLG {
    uint32   len_str;
    char     str[len_str];
    DataType data_type;
    uint32   num_obj;
    
    if (data_type == integer_32)
        uint32 u32_obj[num_obj];
    else if (data_type == float_32)
        float  f32_obj[num_obj];
    else if (data_type == str_ascii) {
        uint32 len_obj;
        char   str_obj[len_obj];
    }
};

void UserDataPLG() {
    uint32 num_entry;
    EntryUserDataPLG entry[num_entry] <optimize=false>;
}

void GeometricPVSPLG() {
    uint32 unk_id;
    uint32 len;
    if (len) {
        uint32 unk;
        ubyte  unk_entry[len];
    }
}

struct IndicesBinMeshPLG(int type) {
    uint32 num_indices;
    uint32 material_index;
    if (type == 16)
        uint16 u16_vert_idx[num_indices];
    else if (type == 32)
        uint32 u32_vert_idx[num_indices];
};

void BinMeshPLG() {
    uint32 is_tri_strip;
    uint32 num_mesh;
    uint32 num_total_indices;
    
    if (num_mesh == 0) // totaly empty
        return;
    if (head.len - 12 == num_mesh * 8) // headers with no data
        IndicesBinMeshPLG mesh_idx_hdr(0)[num_mesh] <optimize=false>;

    else if (head.len - 12 == num_mesh * 8 + num_total_indices * 2) // headers with uint16 data
        IndicesBinMeshPLG mesh_idx_u16(16)[num_mesh] <optimize=false>;

    else if (head.len - 12 == num_mesh * 8 + num_total_indices * 4) // headers with uint32 data
        IndicesBinMeshPLG mesh_idx_u32(32)[num_mesh] <optimize=false>;
}

struct PS2Data {
    uint32 size;
    uint32 unk_noPointers;
    ubyte vif_codes[size];
};

struct RWStructNativeDataPLG {
    RWHead head;
    uint32 platform;
    // it should be in a loop
    if (head.len-4) {
        PS2Data ps2_data[rw_world.rw_material_list.rw_struct.num_material] <optimize=false>;
    }
};

void NativeDataPLG() {
    RWStructNativeDataPLG rw_struct;
}

void UnkWorldPLG() {
    ubyte unk_world_data[head.len];
}
